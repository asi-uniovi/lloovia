import pandas as pd
import lloovia
import pickle
import pulp
import re


###############################################################################
# Helper functions for performing the experiments
###############################################################################
def load_workload(filename, level):
    df = pd.read_csv(filename, index_col=0)
    return df.loc[:, str(level)].values


def load_infrastructure(filename):
    with open(filename, "rb") as f:
        return pickle.load(f)


def perform_experiment_phase_I(infrastructure_file,
                               workload_file,
                               level,
                               max_bins,
                               output_file,
                               frac_gap=0.01,
                               max_seconds=10*60):
    problem = lloovia.Problem(load_infrastructure(infrastructure_file),
                              load_workload(workload_file, level))
    phaseI = lloovia.PhaseI(problem)
    solver = pulp.COIN(threads=2, fracGap=frac_gap,
                       maxSeconds=max_seconds, msg=1)
    phaseI.solve(max_bins=max_bins, solver=solver)
    phaseI.solution.save(output_file)


###############################################################################
# Helper functions for processing the pickles generated by the experiments
###############################################################################
experiment_with_bins_pattern = re.compile(
                    r"(?P<folder>.*?)case_(?P<case_name>[a-z]+)"
                    r"_level_(?P<level>\d+)"
                    r"_bins_(?P<bins>\d+)\.pickle")
experiment_without_bins_pattern = re.compile(
                    r"(?P<folder>.*?)case_(?P<case_name>[a-z]+)"
                    r"_level_(?P<level>\d+)_nobins.pickle")


def extract_info_from_filename(filename):
    m1 = re.match(experiment_with_bins_pattern, filename)
    m2 = re.match(experiment_without_bins_pattern, filename)
    if m1:
        return (m1.group("folder"),
                m1.group("case_name"),
                int(m1.group("level")),
                int(m1.group("bins")))
    elif m2:
        return (m2.group("folder"),
                m2.group("case_name"),
                int(m2.group("level")),
                None)
    else:
        raise Exception("Filename %s doesnt match expected pattern" % filename)


def preprocess_filenames(file_list):
    """Checks that the filenames conform to the expected pattern, and
    that all of them belong to the same experimental scenario. Returns
    the name and level of the experimental scenario and the list of
    max_bins cases"""
    # Preprocess filenames to ensure they are consistent, and extract
    # info to later visit them in proper order
    folders = set()
    cases = set()
    levels = set()
    bins = list()
    for f in file_list:
        folder, case, level, max_bins = extract_info_from_filename(f)
        folders.add(folder)
        cases.add(case)
        levels.add(level)
        bins.append(max_bins)

    if len(cases) > 1 or len(levels) > 1 or len(folders) > 1:
        raise Exception("The list of files to process contains mixed "
                        "experimental scenarios")

    folder = folders.pop()
    case = cases.pop()
    level = levels.pop()
    return (folder, case, level, bins)


def get_info_from_experiment(folder, case, level, max_bins):
    """Reads the solution of a single experiment from a pickle file,
    extract the relevant data and returns it as a dictionary"""

    if max_bins is not None:
        filename = "{}case_{}_level_{}_bins_{}.pickle".format(
                        folder, case, level, max_bins)
    else:
        filename = "{}case_{}_level_{}_nobins.pickle".format(
                        folder, case, level)

    s = lloovia.SolutionI.load(filename).solving_stats

    # Ensure that the max_bins stated in the filename matches with
    # the one contained in it
    if s.max_bins != max_bins:
        raise Exception("The file %s contains data for max_bins=%d" %
                        filename, s.max_bins)

    # Store either the optimal solution, or the best known lower bound
    if s.status == "aborted":
        cost = s.lower_bound
    else: 
        cost = s.optimal_cost

    return dict(
            max_bins=s.max_bins,
            cost=cost,
            seconds_to_create=s.creation_time,
            seconds_to_solve=s.solving_time,
            frac_gap=s.frac_gap,
            max_seconds=s.max_seconds,
            status=s.status
           )


def summarize_experiment(file_list, output_file=None):
    """
    The input is a list of pickle filenames. They are expected to have
    the pattern "case_{casename}_level_{number}_bins_{number}.pickle"
    or "case_{casename}_level_{number}_nobins.pickle"

    Returns a single dataframe in which each row is an experiment with
    a different value for max_bins. The columns are the global results
    of the experiment required to plot the graphs (max_bins, cost,
    seconds_to_solve, seconds_to_create, fracGap, maxSeconds, and status).
    """

    folder, case, level, bins = preprocess_filenames(file_list)

    data = []
    for max_bins in bins:
        data.append(get_info_from_experiment(folder, case, level, max_bins))

    df = pd.DataFrame(data)
    # Reorder columns
    df = df[["max_bins", "cost", "seconds_to_solve", "seconds_to_create",
             "frac_gap", "max_seconds", "status"]]
    df.max_bins.fillna(24*365, inplace=True)
    df.max_bins = df.max_bins.astype(int)
    df = df.sort_values(by="max_bins")
    if output_file:
        df.to_pickle(output_file)
    return 
